import { ObjectElement } from "../ObjectElement";
import { findVariable, getElementAttribute } from "../common";
import { PropertyChangeEvent } from "../event/PropertyChangeEvent";
import { ArrayProxy } from "../ArrayProxy";
/**
 * Select Element
 */
export class SelectElement extends ObjectElement {
    /**
     * Constructor
     * @param htmlElement html element
     * @param bindData bind data
     * @param context context
     */
    constructor(htmlElement, bindData, context) {
        super(htmlElement, bindData, context);
        this.defaultOptions = [];
        // checks if
        if (!this.checkIf()) {
            return;
        }
        // adds event listener
        this.getHtmlElement().addEventListener('change', () => {
            let event = new PropertyChangeEvent(this, this.getProperty(), this.getValue(), this.getIndex());
            this.notifyObservers(event);
        }, true);
        // stores default option
        for (let i = 0; i < this.getHtmlElement().options.length; i++) {
            this.defaultOptions.push(this.getHtmlElement().options[i]);
        }
        // option property
        let optionName = getElementAttribute(this.getHtmlElement(), 'option');
        if (optionName) {
            this.option = findVariable(this.getContext(), optionName);
            this.optionValueProperty = getElementAttribute(this.getHtmlElement(), 'option-value-property');
            this.optionTextProperty = getElementAttribute(this.getHtmlElement(), 'option-text-property');
            ArrayProxy.getProxyHandler(this.option).addObserver(this);
            this.updateOptions();
        }
    }
    /**
     * Updates options
     */
    updateOptions() {
        let value = this.getHtmlElement().value;
        this.getHtmlElement().innerHTML = '';
        this.defaultOptions.forEach(defaultOption => {
            this.getHtmlElement().appendChild(defaultOption);
        });
        this.option.forEach(data => {
            let option = document.createElement('option');
            option.value = data[this.optionValueProperty];
            option.appendChild(document.createTextNode(data[this.optionTextProperty]));
            this.getHtmlElement().appendChild(option);
        });
        this.getHtmlElement().value = value;
    }
    /**
     * Overrides update
     * @param observable observable
     * @param event event
     */
    update(observable, event) {
        super.update(observable, event);
        // checks if
        if (!this.checkIf()) {
            return;
        }
        if (this.option) {
            this.updateOptions();
        }
    }
    /**
     * Sets element value
     * @param value value
     */
    setValue(value) {
        this.getHtmlElement().value = value;
        // force select option
        if (!value) {
            for (let i = 0; i < this.getHtmlElement().options.length; i++) {
                let option = this.getHtmlElement().options[i];
                if (!option.nodeValue) {
                    option.selected = true;
                    break;
                }
            }
        }
    }
    /**
     * Gets element value
     */
    getValue() {
        let value = this.getHtmlElement().value;
        if (!value || value.trim().length < 1) {
            value = null;
        }
        return value;
    }
    /**
     * Sets readonly
     * @param readonly readonly or not
     */
    setReadonly(readonly) {
        if (readonly) {
            this.getHtmlElement().style.pointerEvents = 'none';
        }
        else {
            this.getHtmlElement().style.pointerEvents = '';
        }
    }
    /**
     * Sets disable
     * @param disable disable or not
     */
    setDisable(disable) {
        if (disable) {
            this.getHtmlElement().setAttribute('disabled', 'disabled');
        }
        else {
            this.getHtmlElement().removeAttribute('disabled');
        }
    }
}
//# sourceMappingURL=SelectElement.js.map